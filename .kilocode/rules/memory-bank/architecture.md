# Архитектура: Budget Bot

## Обзор системы
Budget Bot — это Telegram-бот для учета финансов, построенный на архитектуре **Local-First**.
Данные первично сохраняются в локальную БД (SQLite), что обеспечивает мгновенный отклик и надежность, а затем асинхронно синхронизируются с Google Sheets.

**Текущее состояние:** Проект находится в процессе миграции от монолитной структуры к модульной архитектуре с использованием Dependency Injection.

## Основные слои системы (Target Architecture)

### 1. Presentation Layer (Handlers)
Слой взаимодействия с пользователем (Telegram/Aiogram). Логика разбита по функциональным доменам ("Feature Slicing"):

* **`handlers/receipts.py`**:
    * Обработка фотографий и файлов.
    * Взаимодействие с API распознавания чеков.
    * FSM сценарии для подтверждения/корректировки данных чека.
* **`handlers/manual.py`**:
    * Ручной ввод транзакций (FSM).
    * "Умный ввод" (Smart Input) через естественный язык ("кофе 300").
    * Работа с черновиками транзакций.
* **`handlers/common.py`**:
    * Команда `/undo`.
    * Отображение и удаление последних транзакций.
    * Базовые команды: `/start`, `/help`, `/cancel`.
    * Регистрация общих меню.

### 2. Service Layer (Business Logic)
Слой бизнес-логики. Не зависит от Telegram API. Работает с Pydantic-моделями (DTO).

* **`TransactionService`**:
    * Центральный оркестратор.
    * Валидация данных.
    * Вызов ML-классификации.
    * Сохранение через репозиторий.
* **`CategoryService`** (вместо `CATEGORY_STORAGE`):
    * Управление списком категорий и ключевых слов.
    * Кэширование и обновление справочников.
* **`ReceiptRecognitionService`**:
    * Изолированная логика работы с внешним API чеков.

### 3. Infrastructure Layer (Data Access)
Слой работы с данными и внешними API.

* **`TransactionRepository`**:
    * Работа с SQLite (aiosqlite).
    * CRUD операции.
    * Управление статусом синхронизации (`is_synced`).
    * Методы для удаления транзакций по деталям.
* **`GoogleSheetsClient`**:
    * Асинхронный клиент (gspread).
    * Очередь записи.
    * Обработка Rate Limits.

### 4. Service Layer (Business Logic)
Слой бизнес-логики. Не зависит от Telegram API. Работает с Pydantic-моделями (DTO).

* **`TransactionService`**:
    * Центральный оркестратор.
    * Валидация данных.
    * Вызов ML-классификации.
    * Сохранение через репозиторий.
    * Удаление транзакций по деталям.
* **`CategoryService`** (вместо `CATEGORY_STORAGE`):
    * Управление списком категорий и ключевых слов.
    * Кэширование и обновление справочников.
* **`ReceiptRecognitionService`**:
    * Изолированная логика работы с внешним API чеков.

### 5. Data Models & DTO
**Принцип:** Четкое разделение между моделями данных и DTO.
1.  **Pydantic DTO:** Все бизнес-модели (Transaction, Category и т.д.) реализованы как Pydantic-модели для валидации данных и сериализации.
2.  **Database Models:** Модели для работы с SQLite (SQLAlchemy или aiosqlite row objects) не должны смешиваться с бизнес-моделями.
3.  **API DTO:** Отдельные модели для взаимодействия с внешними API (чеков, Google Sheets).

## Ключевые архитектурные решения

### 1. Dependency Injection (DI)
**Проблема:** Глобальные синглтоны и жесткая связность.
**Решение:**
* Все сервисы и репозитории инициализируются в `main.py`.
* Зависимости передаются вниз по цепочке (в `__init__` сервисов).
* В хендлеры сервисы попадают через механизм `workflow_data` диспетчера Aiogram или Middleware.
* **Запрещено:** Использовать глобальные переменные для состояния.

### 2. Local-First & Synchronization
**Принцип:** "Сначала локально, потом в облако".
1.  **Write:** Транзакция пишется в SQLite. Пользователь получает "ОК" мгновенно.
2.  **Queue:** Фоновый `SyncWorker` периодически опрашивает БД на предмет записей с `is_synced = 0`.
3.  **Push:** Воркер отправляет данные в Google Sheets. При успехе ставит `is_synced = 1`. При ошибке повторяет позже (Exponential Backoff).

### 3. ML & NLP Pipeline
**Принцип:** Обучение "на лету".
1.  **Input:** Текст чека или ручной ввод.
2.  **Processing:** Лемматизация (`pymorphy3`) -> Выделение признаков.
3.  **Classification:** TF-IDF взвешивание -> Определение категории.
4.  **Feedback:** Если пользователь меняет категорию вручную, модель дообучается на этом примере.


## Структура проекта (Target)

```text
budget_bot/
├── main.py                    # Точка входа, DI контейнер
├── config.py                  # Конфигурация (env vars)
├── handlers/                  # Пакет хендлеров
│   ├── __init__.py
│   ├── common.py
│   ├── receipts.py
│   ├── manual.py
│   └── __init__.py
├── services/                  # Бизнес-логика
│   ├── transaction_service.py
│   ├── category_service.py
│   └── receipt_recognition_service.py
├── models/                    # Pydantic DTO
├── database/                  # SQLite репозитории
├── sheets/                    # GSheets интеграция
└── utils/                     # Вспомогательные функции
